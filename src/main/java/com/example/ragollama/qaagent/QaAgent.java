package com.example.ragollama.qaagent;

import java.util.concurrent.CompletableFuture;

/**
 * Определяет универсальный контракт для всех QA-агентов в системе.
 * <p>
 * Каждый агент представляет собой самодостаточный компонент, способный
 * выполнять одну конкретную задачу. Этот интерфейс позволяет оркестратору
 * единообразно управлять ими, запрашивать их возможности и запускать на выполнение.
 */
public interface QaAgent {

    /**
     * Возвращает уникальное, машиночитаемое имя агента.
     * Используется для идентификации в логах, метриках и API.
     *
     * @return Имя агента (например, "bug-duplicate-detector").
     */
    String getName();

    /**
     * Возвращает человекочитаемое описание того, что делает агент.
     * Используется в UI и документации.
     *
     * @return Описание назначения агента.
     */
    String getDescription();

    /**
     * Проверяет, может ли данный агент обработать предоставленный контекст.
     * <p>
     * Оркестратор использует этот метод для выбора подходящего агента.
     * Например, агент для анализа логов вернет `true`, только если
     * в контексте есть поле `logContent`.
     *
     * @param context Контекст входящего запроса.
     * @return `true`, если агент может обработать этот контекст, иначе `false`.
     */
    boolean canHandle(AgentContext context);

    /**
     * Асинхронно выполняет основную логику агента.
     *
     * @param context Контекст с входными данными для агента.
     * @return {@link CompletableFuture}, который по завершении будет содержать
     * результат работы агента в виде {@link AgentResult}.
     */
    CompletableFuture<AgentResult> execute(AgentContext context);
}
