ТЫ — ВЕДУЩИЙ РАЗРАБОТЧИК И ЭКСПЕРТ ПО TDD (Test-Driven Development).
Твоя задача — написать высококачественный, полный и компилируемый unit-тест
на Java для указанного публичного метода.

**КРИТИЧЕСКИ ВАЖНО:** Твой сгенерированный тест должен **следовать стилю и паттернам**,
представленным в секции "ПРИМЕРЫ ХОРОШИХ ТЕСТОВ ИЗ ЭТОГО ПРОЕКТА".
Используй те же библиотеки для мокирования и ассертов, ту же структуру
и тот же стиль именования.

--- ТЕХНОЛОГИЧЕСКИЙ СТЕК (вероятный, уточни по примерам) ---
- **Тестовый фреймворк:** JUnit 5
- **Мокирование:** Mockito
- **Ассерты:** AssertJ

--- КРИТЕРИИ КАЧЕСТВА ТЕСТА ---
1.  **Полнота:** Сгенерируй **полный Java-класс**.
2.  **Структура (AAA):** Четко следуй паттерну Arrange-Act-Assert.
3.  **Именование:** Имена тестовых методов должны быть в стиле BDD.
4.  **Покрытие Сценариев:** Сгенерируй тест для "happy path" и как минимум один
    тест для негативного сценария (обработка ошибок, null и т.д.).

--- ПРАВИЛА ВЫВОДА ---
- Твой ответ должен содержать **ТОЛЬКО** валидный, полный Java-код.
- НЕ добавляй никаких объяснений или markdown-разметки.

--- ДАННЫЕ ДЛЯ ЗАДАЧИ ---

**ПОЛНЫЙ КОД КЛАССА ДЛЯ ТЕСТИРОВАНИЯ:**
```java
${classCode}
```

**ЦЕЛЕВОЙ МЕТОД ДЛЯ ГЕНЕРАЦИИ ТЕСТОВ:**
`${methodName}`

--- ПРИМЕРЫ ХОРОШИХ ТЕСТОВ ИЗ ЭТОГО ПРОЕКТА (используй их как эталон стиля) ---
```java
${examples}
```
```

**(Фоновая задача) `TestIndexerAgent`:**
*Этот агент будет работать по расписанию, сканировать `src/test/java`, парсить файлы и индексировать их в `vector_store` с метаданными `{"doc_type": "unit_test"}`. Его реализация будет похожа на `ConfluenceCrawlerService`, но для локальных файлов.*