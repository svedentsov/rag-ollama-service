# ===================================================================
# Основные настройки сервера
# ===================================================================
server:
  port: 8080 # Порт, на котором будет работать приложение
  error:
    # Включать stacktrace в ответ об ошибке только при наличии параметра ?trace=true.
    # Безопасная настройка для production.
    include-stacktrace: on_param

spring:
  application:
    name: rag-ollama-service # Имя приложения, используется в логах и метриках
  lifecycle:
    timeout-per-shutdown-phase: 30s # Таймаут для корректного завершения работы приложения (graceful shutdown)
  mvc:
    async:
      # САМЫЙ ВНЕШНИЙ УРОВЕНЬ: Таймаут для асинхронных запросов в контроллерах.
      # Увеличено для предоставления большего запаса времени для LLM.
      # Должен быть больше всех вложенных таймаутов.
      request-timeout: 20m

  # --- FreeMarker Template Engine Configuration ---
  freemarker:
    # Явно указываем Spring Boot, где искать наши шаблоны.
    # Путь должен начинаться с 'classpath:' и указывать на директорию.
    template-loader-path: classpath:/templates/, classpath:/prompts/
    expose-request-attributes: true
    expose-spring-macro-helpers: true
    suffix: .ftl
    # Глобальная настройка для форматирования boolean-значений.
    # 'c' выводит true/false без кавычек, что безопасно для LLM и предотвращает ошибки.
    settings:
      boolean_format: c

  # --- Database & Persistence ---
  datasource:
    # Данные для подключения к PostgreSQL, запущенному в Docker Compose.
    url: jdbc:postgresql://localhost:5432/ragdb
    username: user
    password: password
    driver-class-name: org.postgresql.Driver
  jpa:
    # `validate`: Проверять схему БД на соответствие сущностям при старте.
    # Самый безопасный вариант для production, предотвращающий случайные изменения схемы.
    hibernate:
      ddl-auto: validate
    show-sql: false # !!! PRODUCTION: Установить в `false` для снижения объема логов и повышения производительности.
    properties:
      hibernate:
        format_sql: true # Форматирует SQL для лучшей читаемости в логах.
    open-in-view: false
  flyway:
    enabled: true
    locations: classpath:db/migration # Путь к SQL-миграциям.
  cache:
    type: simple
    cache-names:
      - vector_search_results # Кэш для результатов RAG-поиска.
      - token_counts # Кэш для подсчета токенов.
      - ollama_available_models # Кэш для списка доступных моделей
      - copilot_sessions # Кэш для сессий
      - analytics_cache # Кэш для результатов аналитических запросов
    caffeine:
      # Общие настройки для всех кэшей. Для кэша сессий задаем время жизни.
      spec: "maximumSize=500,expireAfterAccess=30m"

  # ===================================================================
  # AI & RAG Pipeline Configuration
  # ===================================================================
  ai:
    ollama:
      # ВАЖНО: При запуске приложения на хост-машине используется `localhost`.
      # Если бы приложение запускалось в Docker в той же сети,
      # нужно было бы использовать имя сервиса: `http://rag-ollama:11434`.
      base-url: http://localhost:11434
      chat:
        # Теперь это конфигурация ПО УМОЛЧАНИЮ. Она будет использоваться, если модель не переопределена роутером.
        options:
          model: llama3 # Модель по умолчанию, если роутер не сработает
          temperature: 0.7
      embedding:
        options:
          # Модель для создания векторных представлений (эмбеддингов).
          model: mxbai-embed-large
          model-version: "1.0.0"
    vectorstore:
      pgvector:
        table-name: vector_store # Имя таблицы для хранения векторов.
        index-type: HNSW # Тип индекса для быстрого поиска (Hierarchical Navigable Small World).
        distance-type: COSINE_DISTANCE # Метрика для измерения схожести векторов.
        dimensions: 1024 # Размерность вектора (зависит от embedding-модели).

# ===================================================================
# Observability (Monitoring & Metrics)
# ===================================================================
management:
  endpoints:
    web:
      exposure:
        # Убираем prometheus из списка, так как мы удалили его из docker-compose
        include: health, info, metrics, rageval
  endpoint:
    health:
      show-details: always # Показывать детали для health-чеков.
  tracing:
    enabled: false # Явно отключаем автоконфигурацию трассировки
    sampling:
      probability: 0.0 # На всякий случай устанавливаем вероятность семплирования в 0
  metrics:
    tags:
      application: ${spring.application.name} # Глобальный тег для всех метрик.
    distribution:
      # Включить гистограммы для метрики времени ответа HTTP-сервера.
      percentiles-histogram:
        http.server.requests: true
      # Определить "корзины" (SLA) для гистограмм времени ответа.
      sla:
        http.server.requests: 50ms, 100ms, 200ms, 500ms, 1s, 2s

# ===================================================================
# API Documentation (OpenAPI / Swagger)
# ===================================================================
springdoc:
  api-docs:
    path: /api-docs # Путь к JSON-спецификации OpenAPI
  swagger-ui:
    path: /swagger-ui.html # Путь к интерактивной документации Swagger UI
  default-consumes-media-type: application/json
  default-produces-media-type: application/json

# ===================================================================
# Resilience & Fault Tolerance (Resilience4j)
# ===================================================================
resilience4j:
  circuitbreaker:
    instances:
      ollama: # Конфигурация для Ollama
        register-health-indicator: true
        sliding-window-size: 10 # Количество вызовов для анализа.
        minimum-number-of-calls: 3 # Мин. вызовов для срабатывания.
        failure-rate-threshold: 60 # % ошибок для размыкания цепи.
        wait-duration-in-open-state: 15s # Время в "разомкнутом" состоянии.
        record-exceptions: # Считать DataAccessException как сбой
          - org.springframework.dao.DataAccessException
          - java.util.concurrent.TimeoutException
      database:
        register-health-indicator: true
        sliding-window-size: 20
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        record-exceptions:
          - org.springframework.dao.TransientDataAccessException
          - java.sql.SQLTransientException
      jira: # Конфигурация для Jira API
        register-health-indicator: true
        sliding-window-size: 20
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s # Более долгое ожидание, т.к. Jira может быть временно недоступна
        record-exceptions:
          - java.util.concurrent.TimeoutException
          - org.springframework.web.reactive.function.client.WebClientResponseException$ServiceUnavailable
      confluence: # Конфигурация для Confluence API
        register-health-indicator: true
        sliding-window-size: 20
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        record-exceptions:
          - java.util.concurrent.TimeoutException
          - org.springframework.web.reactive.function.client.WebClientResponseException$ServiceUnavailable
  retry:
    instances:
      ollama:
        max-attempts: 2
        wait-duration: 5s
        retry-on-exception: "org.springframework.web.reactive.function.client.WebClientRequestException, org.springframework.web.client.ResourceAccessException, java.util.concurrent.TimeoutException"
      database:
        max-attempts: 3
        wait-duration: 200ms
        retry-exceptions:
          - org.springframework.dao.TransientDataAccessException
          - java.util.concurrent.TimeoutException
          - java.sql.SQLTransientException
      jira: # Конфигурация для Jira API
        max-attempts: 3
        wait-duration: 1s
        retry-on-exception: "org.springframework.web.reactive.function.client.WebClientRequestException, java.util.concurrent.TimeoutException, org.springframework.web.reactive.function.client.WebClientResponseException$ServiceUnavailable"
      confluence: # Конфигурация для Confluence API
        max-attempts: 3
        wait-duration: 2s # Задержка побольше, т.к. API может быть под нагрузкой
        retry-on-exception: "org.springframework.web.reactive.function.client.WebClientRequestException, java.util.concurrent.TimeoutException, org.springframework.web.reactive.function.client.WebClientResponseException$ServiceUnavailable"
  timelimiter:
    instances:
      ollama:
        timeout-duration: 20m
        cancel-running-future: true
      database:
        timeout-duration: 10s
        cancel-running-future: true
      jira: # Конфигурация для Jira API
        timeout-duration: 15s # Внешние API должны отвечать быстро
        cancel-running-future: true
      confluence: # Конфигурация для Confluence API
        timeout-duration: 20s
        cancel-running-future: true

# ===================================================================
# Custom Application Properties (app.*)
# ===================================================================
app:
  llm: # Конфигурация LLM Роутера
    fallback-model: "phi3" # Имя модели, которая будет использоваться, если основная модель недоступна.
    models: # Маппинг абстрактных возможностей на конкретные имена моделей в Ollama.
      FASTEST: "phi3" # Для задач, где скорость > точность формата
      FAST_RELIABLE: "phi3" # Используем llama3 для надежных задач
      BALANCED: "llama3" # Основная модель для RAG и чата
      VISION: "llava" # Мультимодальная модель для анализа изображений

  prompt:
    rag-template-path: "rag-prompt.ftl"

  reranking:
    enabled: true
    strategies:
      keyword-boost:
        enabled: true
        boost-factor: 0.1
      llm:
        enabled: false
      diversity:
        enabled: true
        lambda: 0.5

  rate-limiting:
    enabled: true
    limits:
      - endpoint: "/api/v1/orchestrator/ask"
        capacity: 20
        refill-period-minutes: 1

  tokenization:
    encoding-model: "o200k_base"

  context:
    max-tokens: 8000

  chat:
    history:
      max-messages: 10 # Количество последних сообщений для поддержания контекста.

  ingestion:
    chunking:
      default-chunk-size: 256
      chunk-overlap: 32

  http-client:
    connect-timeout: 5s
    response-timeout: 30s
    read-write-timeout: 30s
    ollama:
      response-timeout: 15m
      read-write-timeout: 15m

  task-executor: # Настройки основного пула потоков для @Async задач.
    core-pool-size: 4
    max-pool-size: 16
    queue-capacity: 100
    thread-name-prefix: "app-async-"

  llm-executor: # Конфигурация для выделенного пула потоков LLM
    core-pool-size: 8 # Больше потоков, т.к. операции долгие
    max-pool-size: 32
    queue-capacity: 200
    thread-name-prefix: "llm-async-"

  db-executor: # Конфигурация для выделенного пула потоков БД
    core-pool-size: 2 # Меньше потоков, т.к. операции быстрые
    max-pool-size: 8
    queue-capacity: 50
    thread-name-prefix: "db-async-"

  vector-store: # Настройки для векторного хранилища (pgvector)
    # Параметры HNSW-индекса для тюнинга производительности и точности.
    # Изменять с осторожностью, требуется профилирование.
    index:
      # Количество соседей на слой графа.
      # Trade-off: выше значение -> лучше точность, медленнее индексация.
      m: 32
      # Глубина поиска при построении индекса.
      # Trade-off: выше значение -> лучше качество индекса, значительно медленнее индексация.
      ef-construction: 128
      # Глубина поиска во время запроса.
      # Trade-off: выше значение -> лучше точность (recall), выше задержка (latency).
      ef-search: 64

  rag: # Настройки RAG-конвейера
    # Стратегия поведения, если поиск не нашел документов.
    # "fixed" - вернуть стандартный ответ (быстро, безопасно).
    # "delegate" - (потребует реализации) попросить LLM ответить из общих знаний.
    no-context-strategy: fixed
    arrangement-strategy: sandwich
    summarizer:
      enabled: false
    validation:
      enabled: true # Включаем AI-Критика
    retrieval:
      hybrid:
        expansion-min-docs-threshold: 3
        vector-search:
          top-k: 5
          similarity-threshold: 0.72
        fts:
          top-k: 10

  expansion:
    graph:
      enabled: true

  evaluation:
    f1-score-threshold: 0.85
    scheduler:
      enabled: true
      cron: "0 0 3 * * ?" # Запускать каждый день в 3:00 ночи

  optimization:
    index:
      enabled: true
      cron: "0 0 4 * * ?" # Каждый день в 4 часа утра
      stale-document-detection:
        enabled: true
    embedding-drift:
      scheduler:
        enabled: true
        cron: "0 0 2 * * ?" # Каждый день в 2 часа ночи
    guardian:
      scheduler:
        enabled: true
        cron: "0 0 1 * * ?" # Каждый день в 1 час ночи

  curation: # Настройки для Knowledge Curator Agent
    scheduler:
      enabled: true
      cron: "0 0 5 * * ?" # Каждый день в 5 утра

  analysis: # Настройки для аналитических агентов
    flakiness:
      # Порог в процентах. Тест считается "flaky", если падает чаще, чем в 5% случаев.
      failure-rate-threshold: 5.0
      # Минимальное количество запусков теста, чтобы он попал в анализ.
      # Предотвращает ложные срабатывания для новых тестов.
      min-runs-threshold: 10
    cost-model:
      per-dev-hour: 100.0
      per-support-ticket: 25.0
      per-lost-user: 200.0
    autonomy:
      cron: "0 0 7 * * MON-FRI" # Запуск автономного анализа в 7 утра по будням
  health-monitor:
    scheduler:
      enabled: true
      # Запускать каждый понедельник в 8 утра
      cron: "0 0 8 * * MON"

  integrations:
    github:
      # Секрет, который вы настраиваете в GitHub для подписи веб-хуков.
      # !!! ВАЖНО: В production вынести в переменные окружения или Vault.
      webhook-secret: "your_super_secret_string_here"
      # Персональный токен доступа (PAT) для аутентификации в GitHub API.
      # !!! ВАЖНО: В production вынести в переменные окружения или Vault.
      api-token: "ghp_YourGitHubPersonalAccessToken"
    jira:
      # Jira не использует HMAC-подпись по умолчанию.
      # Часто используется Basic Auth или API Token в заголовке для "секретности".
      # Здесь мы будем использовать простой токен для проверки.
      webhook-secret-token: "your_jira_secret_token"
      # URL вашего инстанса Jira
      base-url: "https://your-domain.atlassian.net"
      # Email пользователя для API
      api-user: "your-email@example.com"
      # API токен, сгенерированный в Jira
      api-token: "YourJiraApiToken"
    confluence:
      # URL вашего инстанса Confluence. Пример: https://your-domain.atlassian.net
      base-url: "https://your-domain.atlassian.net"
      # Email пользователя для API
      api-user: "your-email@example.com"
      # API токен, сгенерированный в Confluence
      api-token: "YourConfluenceApiToken"
    git:
      # URL для клонирования/fetch репозитория
      repository-url: "https://github.com/your-org/your-repo.git"
      # Персональный токен доступа (PAT) с правами на чтение репозитория
      personal-access-token: "ghp_YourGitPersonalAccessToken"
    ci:
      base-url: "http://your-jenkins-instance:8080"
      username: "your-ci-user"
      api-token: "YourCiApiTokenOrPassword"
      rollback-job-name: "deploy-rollback"
    neo4j:
      uri: "bolt://localhost:7687"
      username: "neo4j"
      password: "password"

  security: # Настройки безопасности
    pii-redaction:
      # Глобальный переключатель для сервиса маскирования.
      # Установите в 'false' для отключения маскирования.
      enabled: true
      # Список регулярных выражений для поиска чувствительных данных.
      # ВАЖНО: Тщательно протестируйте паттерны на ваших данных.
      patterns:
        # Универсальный паттерн для Email
        - "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b"
        # Паттерн для номеров телефонов (упрощенный, для примера)
        - "\\b(?:\\+?7|8)?[\\s\\-]?\\(?\\d{3}\\)?[\\s\\-]?\\d{3}[\\s\\-]?\\d{2}[\\s\\-]?\\d{2}\\b"
        # Паттерн для поиска API-ключей (например, GitHub ghp_..., Stripe sk_live_...)
        - "\\b(ghp|sk_live|rk_live)_[a-zA-Z0-9]{20,}\\b"
        # Паттерн для поиска JWT токенов
        - "ey[a-zA-Z0-9_\\-]+\\.[a-zA-Z0-9_\\-]+\\.[a-zA-Z0-9_\\-]+"
        # Паттерн для поиска IP-адресов
        - "\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b"
  indexing:
    test-files:
      path: "src/test/java"
      scheduler:
        enabled: true
        cron: "0 0 5 * * ?" # Каждый день в 5 утра

  knowledge-domains:
    domains:
      - name: "technical_docs"
        description: "Техническая документация, архитектурные решения, API-спецификации, гайды по настройке и развертыванию."
      - name: "test_cases"
        description: "База знаний по тест-кейсам. Содержит описания тестовых сценариев, шаги воспроизведения и ожидаемые результаты."
      - name: "hr_policy"
        description: "Документы кадровой службы: политика отпусков, больничных, правила внутреннего распорядка."

  federation:
    # Каталог проектов, подлежащих федеративному анализу.
    # `id` должен соответствовать `projectId` в таблице `test_run_metrics`.
    projects:
      - id: "rag-ollama-service"
        name: "Основной RAG Сервис"
        gitUrl: "https://github.com/svedentsov/rag-ollama-service.git"
      - id: "notification-service"
        name: "Сервис Уведомлений"
        gitUrl: "https://github.com/svedentsov/notification-service.git"
      - id: "payment-gateway"
        name: "Платежный Шлюз"
        gitUrl: "https://github.com/svedentsov/payment-gateway.git"

  finops:
    quotas:
      enabled: true
      # Тарифный план по умолчанию для пользователей без явно указанного
      default-tier: "free"
      # Описание тарифных планов
      tiers:
        free:
          total-tokens-limit: 5000000
        pro:
          total-tokens-limit: 5000000
        developer:
          total-tokens-limit: 2000000
      # Стоимость в USD за 1000 токенов (для отчетов)
      costs:
        input: 0.0005  # Примерная стоимость
        output: 0.0015 # Примерная стоимость
